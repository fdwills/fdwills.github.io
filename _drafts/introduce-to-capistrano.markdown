---
layout: post
title:  "【译】Capistrano介绍"
date:   2014-01-21 20:44:57
categories: auto deploy
tags: 自动化
---
翻译来自GREE开发者博客上的文章。[链接][capistrano]
译者水平有限翻译如有误请指出。
<h2>开始</h2>

这篇是GREE Advent Calendar 2013年21日文章。呈上！
大家好，我是九冈。在GREE公司，我为了巩固Java以及Scala的传播基础，一个人制作了发布和监视的系统。
这次将在这个工程中学习到的知识以这片名叫【Capistrano 3入门博客】的形式共享出来。

<h2>想将所有产生手动操作的可能性消灭在萌芽状态</h2>

这篇博客将介绍Capistrano 3的基础。Capistrano 3是基于Ruby的服务器操作以及自动发布的攻击。Capistrano 3的利用能够将系统发布等复杂的服务器操作自动化。这篇博客里将特别以发布为焦点，说明如何利用Capistrano将服务器操作自动化。

学习Capistrano 3是需要花点时间的。为了降低各位所花的时间，于是我写了这篇文章。此处套话略去1000字。。。

<h2>对象</h2>

这片博客的对象是以下各位
1. 想知道Capistrano的概要的各位
2. 想学着使用Capistrano的各位
3. 想将手工操作自动化的各位
4. 已经通过其他工具实现了自动化

以上述各位作为对象，读了这篇博客之后能取得不错的收获事本文的目标。
（对于已经通过诸如Capistrano、Ansible、Fabic之类的工具实现了服务器操作自动化的各位，可能就没有什么新意了）

<h2>为什么deploy会花费大量的功夫</h2>

将做好的网络服务之类的应用发布给用户用，并不仅仅是开发这些应用，实际上还必须要讲这些服务放在服务器上让之运行。而且，这些应用的发布，意外的能花费大量的时间。究其原因，是因为发布相关的需求本身就存在这诸多分歧。

<h2>发布的需求是什么？</h2>
发布的需求大致有以下这些。

1. 应用的构成要素
2. 实施的环境与规模
3. 允许的发布时间间隔
4. 发布的最后期限
5. 预算是多少

<h3>应用的构成要素</h3>
采用什么语言开发，框架，是不是有中间层的应用

<h3>实施环境和规模</h3>
发布在什么样的服务器，多少台上

<h3>允许的发布时间间隔</h3>
从发布开始到发布结束花多少时间为好

<h3>发布的最后期限</h3>
有没有写自动化脚本的时间

<h3>预算是多少</h3>

为什么写自动化脚本会花费初期预算？
比如说，每次都用同样的语言开发，使用同样的框架和中间件，每次都发布在同样的服务器上的话，事情就简单了。但是如果不是这样发布的难度就会增加 。

<h2>手动作业好不好？</h2>

前述的分歧较多的发布需求，我们采用自动化或者手动作业来完成。

手动作业虽然有初期零投入的优点，但是须要不断有人持续的来写操作说明，并且反复操作过程中有出现错误的可能也是它的一个缺点。这就是想做自动化的原因。

<h2>那就做自动化不就好了么？</h2>
虽然这样想，但是做自动化有不得不翻越的壁垒。生成性壁垒和保守性壁垒。

<h3>生产性壁垒</h3>
用shell脚本？Ant？Ansible？Fabric？Capistrano？

开发新项目的时候，是建立自己的发布系统，还是利用现有的比如OSS之类系统，都是一个选项。单独的发布系统编码和测试需要花功夫，用现有的系统的时候学习需要花功夫。想尽早开始开心的编码起来。

<h3>保守性壁垒</h3>

沿用性？扩展性？
如果自己开发，沿用性有时候非常的困难。设计和编码的重点在什么能够设定，什么不能设定。如果能够留下充足的文档自然非常好，但是也时常有因为时间和预算的原因只够写完脚本而不能完成文档。

<h2>想自动化</h2>

因为这种原因，实际上我们在将发布自动化的时候，不得不考虑发布系统的沿用性和扩展性问题。这很难取舍。譬如“这次没时间了就手动操作”“先不管怎样自动化做起来，需要的时候在写文档”，也是没办法的事情。

但是，如果说理想情况，那就是超越生产性和保守的屏障做好自动化。

<h2>用Capistrano 3开始做自动化</h2>
越过上面所述的生产性和保守性的壁垒的一个方法是，降低学习以及持续的成本。本文就是出于这个目的。

<h2>期待的结果</h2>

采用Capistrano带来的变化
采用Capistrano，能够将各种发布流程同一成所谓的【Capistrano的设定】。

这种变化带来的优点和缺点是什么的？

<h3>优点</h3>

<h4>保守性程度高~maintainable~</h4>

写脚本的人设计思想是不一样的，读懂别人的设计思想是需要花时间的。如果大家都懂Capistrano的话，别人写的发布的设定动起来就很容易，就会导致保守性可持续性变高。

<h4>生成性程度高~productive~</h4>

shell脚本的话，通过软件包管理软件安装要使用的工具，或者通过git获取所需要的脚本，不同的人不同的组织有不同的选择方法。安装的话通过bundle install命令能将包括Capistrano本身，库文件以及扩展在内的所有囊括进来。

<h4>柔软度高~flexible~</h4>
是不是手上已经有为了发布而写的说明文档或者shell脚本了呢？
因为Capistrano任务本身只是“按照一定的顺序执行脚本”，这就和为了发布为写的脚本和操作流程是一样的。用nohup将操作放到后台运行，upstart/monit/daemontools/god之类的模块化，进程监视，进程ID的管理之类的脚本等等上述通过Ruby代码表象出来就行了。所以，如果与发布相关的东西，如果写进了Capistrano里，就很少有被限制的需求。

<h4>易读易写</h4>

能够用就像英语一样的精炼的DSL编写代码

而且，本地环境与服务器的操作在DSL语法上呗明确的区分开来。首先本地环境上做什么，服务器环境生做什么，所谓的基于大局的脚本在写法上被很自然的呗规约起来。

<h3>缺点</h3>


续。。。





[link]: http://labs.gree.jp/blog/2013/12/10084/
